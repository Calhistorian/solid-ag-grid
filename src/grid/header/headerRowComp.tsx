import {
  AbstractHeaderCellCtrl,
  HeaderCellCtrl,
  HeaderFilterCellCtrl,
  HeaderGroupCellCtrl,
  HeaderRowCtrl,
  HeaderRowType,
  IHeaderRowComp,
} from "ag-grid-community";
import { createMemo, createSignal, For, onMount, useContext } from "solid-js";
import { BeansContext } from "../core/beansContext";
import HeaderCellComp from "./headerCellComp";
import HeaderFilterCellComp from "./headerFilterCellComp";
import HeaderGroupCellComp from "./headerGroupCellComp";

const HeaderRowComp = (props: { ctrl: HeaderRowCtrl }) => {
  const { gos } = useContext(BeansContext);
  const { ctrl } = props;

  const [getHeight, setHeight] = createSignal<string>();
  const [getTop, setTop] = createSignal<string>();
  const [getWidth, setWidth] = createSignal<string>();
  const [getAriaRowIndex, setAriaRowIndex] = createSignal<number>(
    ctrl.getAriaRowIndex()
  );
  const [getCellCtrls, setCellCtrls] = createSignal<AbstractHeaderCellCtrl[]>(
    []
  );

  let eGui: HTMLDivElement;

  /**
   * Creates a Map from an array using a callback to generate the keys.
   * @param arr - The array to map.
   * @param callback - The function to generate keys from array elements.
   * @returns A Map with keys generated by the callback and values from the array.
   */
  const mapById = <V_1,>(
    arr: V_1[],
    callback: (obj: V_1) => string
  ): Map<string, V_1> => {
    const map = new Map<string, V_1>();
    arr.forEach((item) => {
      map.set(callback(item), item);
    });
    return map;
  };

  const setCellCtrlsMaintainOrder = (next: AbstractHeaderCellCtrl[]) => {
    const prev = getCellCtrls();
    const isEnsureDomOrder = gos.get("ensureDomOrder");
    const isPrintLayout = gos.isDomLayout("print");

    // if we are ensuring dom order, we set the ctrls into the dom in the same order they appear on screen
    if (isEnsureDomOrder || isPrintLayout) {
      return next;
    }

    // if not maintaining order, we want to keep the dom elements we have and add new ones to the end,
    // otherwise we will loose transition effects as elements are placed in different dom locations
    const prevMap = mapById(prev, (c) => c.getInstanceId());
    const nextMap = mapById(next, (c) => c.getInstanceId());

    const oldCtrlsWeAreKeeping = prev.filter((c) =>
      nextMap.has(c.getInstanceId())
    );
    const newCtrls = next.filter((c) => !prevMap.has(c.getInstanceId()));

    const nextOrderMaintained = [...oldCtrlsWeAreKeeping, ...newCtrls];
    setCellCtrls(nextOrderMaintained);
  };

  onMount(() => {
    const compProxy: IHeaderRowComp = {
      setHeight: (height) => setHeight(height),
      setTop: (top) => setTop(top),
      setHeaderCtrls: (ctrls) => setCellCtrlsMaintainOrder(ctrls),
      setWidth: (width) => setWidth(width),
    };
    ctrl.setComp(compProxy);
  });

  const style = createMemo(() => ({
    height: getHeight(),
    top: getTop(),
    width: getWidth(),
  }));

  const cssClasses = ctrl.getHeaderRowClass();

  const createCellJsx = (cellCtrl: AbstractHeaderCellCtrl) => {
    switch (ctrl.getType()) {
      case HeaderRowType.COLUMN_GROUP:
        return <HeaderGroupCellComp ctrl={cellCtrl as HeaderGroupCellCtrl} />;

      case HeaderRowType.FLOATING_FILTER:
        return <HeaderFilterCellComp ctrl={cellCtrl as HeaderFilterCellCtrl} />;

      default:
        return <HeaderCellComp ctrl={cellCtrl as HeaderCellCtrl} />;
    }
  };

  // below, we are not doing floating filters, not yet
  return (
    <div
      ref={eGui!}
      class={cssClasses}
      role="row"
      style={style()}
      aria-rowindex={getAriaRowIndex()}
    >
      <For each={getCellCtrls()}>
        {(cellCtrl, i) => createCellJsx(cellCtrl)}
      </For>
    </div>
  );
};

export default HeaderRowComp;
